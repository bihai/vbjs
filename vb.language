start
    = module EOF
    / expression EOF

module = __ declarations func_defs

declarations = declaration* _
declaration = (OPTION / ATTRIBUTE) [^\r\n]* EOS

func_defs = func_def*
func_def = func_start uname args_spec statements func_end
func_start
    = PRIVATE? FUNCTION
    / PRIVATE? SUB
func_end
    = END FUNCTION __
    / END SUB __
args_spec = LEFT_PAREN (uname (comma uname)* )? RIGHT_PAREN type_spec? EOS
statements = (single_line_statement / multiline_statement)*
type_spec = AS identifier_expr
on_error_statement = ONERROR (GOTO uname / RESUME NEXT)

multiline_statement = if_statement EOS
single_line_statement = statement EOS
statement
    = resume_statement
    / exit_statement
    / on_error_statement
    / dim_statement
    / set_statement
    / single_line_if_statement
    / assign_statement
    / label_statement
    / call_statement
resume_statement = RESUME uname
exit_statement = EXIT FUNCTION
dim_statement = DIM uname AS identifier_expr
set_statement = (CONST / SET) uname EQUAL expression
if_statement = IF expression THEN EOS statements ENDIF
single_line_if_statement = IF expression THEN statement
assign_statement = identifier_expr EQUAL expression
label_statement = uname COLON
call_statement = callee call_spec?
callee = uname (identifier_op uname)*
call_spec
    = LEFT_PAREN call_args RIGHT_PAREN
    / call_args
call_args = (expression (comma expression)* )?

expression
    = expression_in_braces
    / or_expr

expression_in_braces = LEFT_PAREN expression RIGHT_PAREN

or_expr = cmp_expr (OR cmp_expr)*

cmp_expr = concat_expr (EQUAL concat_expr)?

concat_expr
    = add_expr (concat_op add_expr)*

add_expr
    = call_expr (plus_op call_expr)*

call_expr
    = lazy_call_expr
    / value
    / plain_call_expr

plain_call_expr
    = name LEFT_PAREN (expression (comma expression)* )? RIGHT_PAREN

lazy_call_expr
    = lazy_name LEFT_PAREN (lazy_value (comma lazy_value)* )? RIGHT_PAREN

lazy_value
    = bracketed_identifier
    / literal
    
value
    = identifier_expr
    / literal
    / TRUE
    / FALSE
    / number

identifier_expr = identifier_expr_part (identifier_op identifier_expr_part)*
identifier_expr_part
    = plain_call_expr
    / identifier

identifier
    = bracketed_identifier
    / uname
bracketed_identifier = '[' name_in_brackets ']' _
name_in_brackets = [A-Za-z_][A-Za-z0-9_ ]*
name = [A-Za-z_][A-Za-z0-9_]* _

lazy_name = 'Sum' _
literal = '"' literal_text '"' _
literal_text = [^"]*
concat_op = '&' _
plus_op = '+' _
comma = ',' _
identifier_op = '!' / '.'
number = [0-9]+ _

uname = !(keyword ![A-Za-z0-9_]) uname_itself _
uname_itself = [A-Za-z_][A-Za-z0-9_]*
FUNCTION = 'Function' _
SUB = 'Sub' _
PRIVATE = 'Private' _
END = 'End' _
OPTION = 'Option' _
ATTRIBUTE = 'Attribute' _
ONERROR = 'On' [ \t]+ 'Error' _
GOTO = 'GoTo' _
RESUME = 'Resume' _
EXIT = 'Exit' _
NEXT = 'Next' _
DIM = 'Dim' _
CONST = 'Const' _
SET = 'Set' _
IF = 'If' _
THEN = 'Then' _
ENDIF = END IF _
EQUAL = '=' _
COLON = ':' _
TRUE = 'True' _
FALSE = 'False' _
LEFT_PAREN = '(' _
RIGHT_PAREN = ')' _
OR = 'Or' _
keyword
    = 'End'
    / 'Function'
    / 'Then'
    / 'If'
    / 'Set'
    / 'Const'
    / 'Or'
AS = 'As' _

// optional whitespace
_ = ([ \t] / line_continuation)*

// greedy whitespace (eats new lines)
__ = ([ \t\r\n] / comment)*

comment = _ "'" [^\r\n]* EOL
line_continuation = '_' _ EOL

EOS = (!('_' _) EOL _ / comment _)+
EOL = [\r\n] / EOF
EOF = !.
