start
    = module EOF
    / expression EOF

module = _ declarations func_defs

declarations = declaration* _
declaration = (OPTION / ATTRIBUTE) [^\r\n]* EOL

func_defs = func_def*
func_def = func_start uname args_spec statements func_end
func_start
    = PRIVATE? FUNCTION
    / PRIVATE? SUB
func_end
    = END FUNCTION
    / END SUB
args_spec = LEFT_PAREN (uname (comma uname)* )? RIGHT_PAREN type_spec? on_error?
statements = statement*
type_spec = AS identifier_expr
on_error = ONERROR GOTO uname

statement
    = resume_statement
    / exit_statement
    / dim_statement
    / set_statement
    / if_statement
    / assign_statement
    / label_statement
    / call_statement
resume_statement = RESUME uname
exit_statement = EXIT FUNCTION
dim_statement = DIM uname AS identifier_expr
set_statement = (CONST / SET) uname EQUAL expression
if_statement = IF expression THEN statements ENDIF
assign_statement = identifier_expr EQUAL expression
label_statement = uname COLON
call_statement = callee call_args?
callee = uname (identifier_op uname)*
call_args = LEFT_PAREN (expression (comma expression)* )? RIGHT_PAREN

expression
    = expression_in_braces
    / or_expr

expression_in_braces = LEFT_PAREN expression RIGHT_PAREN

or_expr = cmp_expr (OR cmp_expr)*

cmp_expr = concat_expr (EQUAL concat_expr)?

concat_expr
    = add_expr (concat_op add_expr)*

add_expr
    = call_expr (plus_op call_expr)*

call_expr
    = lazy_call_expr
    / value
    / plain_call_expr

plain_call_expr
    = name LEFT_PAREN (expression (comma expression)* )? RIGHT_PAREN

lazy_call_expr
    = lazy_name LEFT_PAREN (lazy_value (comma lazy_value)* )? RIGHT_PAREN

lazy_value
    = bracketed_identifier
    / literal
    
value
    = identifier_expr
    / literal
    / TRUE
    / FALSE
    / number

identifier_expr = identifier_expr_part (identifier_op identifier_expr_part)*
identifier_expr_part
    = plain_call_expr
    / identifier

_ = ( [ \t\r\n] / comment / '_')*
__ = [ \t]*

comment = "'" [^\r\n]*

identifier
    = bracketed_identifier
    / uname
bracketed_identifier = '[' name_in_brackets ']' __
name_in_brackets = [A-Za-z_][A-Za-z0-9_ ]*
name = [A-Za-z_][A-Za-z0-9_]* _

lazy_name = 'Sum'
literal = '"' literal_text '"' _
literal_text = [^"]*
concat_op = '&' __
plus_op = '+' __
comma = ',' __
identifier_op = '!' / '.'
number = [0-9]+ _

uname = !(keyword ![A-Za-z0-9_]) uname_itself _
uname_itself = [A-Za-z_][A-Za-z0-9_]*
FUNCTION = 'Function' _
SUB = 'Sub' _
PRIVATE = 'Private' _
END = 'End' __
OPTION = 'Option' __
ATTRIBUTE = 'Attribute' __
ONERROR = 'On' [ \t]+ 'Error' __
GOTO = 'GoTo' __
RESUME = 'Resume' __
EXIT = 'Exit' __
DIM = 'Dim' __
CONST = 'Const' __
SET = 'Set' __
IF = 'If' __
THEN = 'Then' _
ENDIF = END IF _
EQUAL = '=' __
COLON = ':' _
TRUE = 'True' _
FALSE = 'False' _
LEFT_PAREN = '(' _
RIGHT_PAREN = ')' _
OR = 'Or' _
keyword
    = 'End'
    / 'Function'
    / 'Then'
    / 'If'
    / 'Set'
    / 'Const'
    / 'Or'
AS = 'As' __

EOF = !.
EOL = [\r\n]+ / EOF
